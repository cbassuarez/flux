import type { FontFallbackOption, FontsPreset, PageSizeOption, ThemeOption } from "../config.js";

export type TemplateName = "demo" | "article" | "spec" | "zine" | "paper" | "blank";

export interface TemplateOptions {
  title: string;
  page: PageSizeOption;
  theme: ThemeOption;
  fonts: FontsPreset;
  fontFallback: FontFallbackOption;
  assets: boolean;
  chapters: number;
  live: boolean;
}

export interface TemplateOutput {
  mainFlux: string;
  readme: string;
  chapters: { path: string; content: string }[];
  assetsDir?: string;
}

export interface TemplateDefinition {
  name: TemplateName;
  description: string;
  build(options: TemplateOptions): TemplateOutput;
}

type FontStack = { primary: string; fallback: string };

const FONT_PRESETS: Record<FontsPreset, { body: FontStack; heading: FontStack; mono: FontStack }> = {
  tech: {
    body: { primary: "Inter", fallback: "Helvetica Neue, Arial, sans-serif" },
    heading: { primary: "IBM Plex Sans", fallback: "Inter, Helvetica Neue, Arial, sans-serif" },
    mono: { primary: "JetBrains Mono", fallback: "Source Code Pro, Menlo, monospace" },
  },
  bookish: {
    body: { primary: "Iowan Old Style", fallback: "Palatino Linotype, Palatino, Times New Roman, serif" },
    heading: { primary: "Iowan Old Style", fallback: "Palatino Linotype, Palatino, Times New Roman, serif" },
    mono: { primary: "Source Code Pro", fallback: "Courier New, monospace" },
  },
};

const PAGE_SIZES: Record<PageSizeOption, { width: number; height: number; units: string }> = {
  Letter: { width: 8.5, height: 11, units: "in" },
  A4: { width: 210, height: 297, units: "mm" },
};

export function getTemplate(name: string): TemplateDefinition | null {
  const templates: TemplateDefinition[] = [
    {
      name: "demo",
      description: "Live slots + assets + annotations",
      build: buildDemoTemplate,
    },
    {
      name: "article",
      description: "Narrative article starter",
      build: buildArticleTemplate,
    },
    {
      name: "spec",
      description: "Technical spec layout",
      build: buildSpecTemplate,
    },
    {
      name: "zine",
      description: "Visual zine layout",
      build: buildZineTemplate,
    },
    {
      name: "paper",
      description: "Academic paper with abstract",
      build: buildPaperTemplate,
    },
    {
      name: "blank",
      description: "Minimal blank document",
      build: buildBlankTemplate,
    },
  ];
  return templates.find((t) => t.name === name) ?? null;
}

function buildBaseDoc(options: TemplateOptions, bodyContent: string, extraBlocks: string[] = []): string {
  const size = PAGE_SIZES[options.page];
  const fonts = FONT_PRESETS[options.fonts];
  const fontBody = formatFontStack(fonts.body, options.fontFallback);
  const fontHeading = formatFontStack(fonts.heading, options.fontFallback);
  const fontMono = formatFontStack(fonts.mono, options.fontFallback);
  const target = options.theme === "both" ? "screen" : options.theme;
  const themeBlock = options.theme !== "screen"
    ? [
        "  /// Optional print theme overrides for exports.",
        "  theme \"print\" {",
        "    tokens {",
        "      color.text = \"#1b1a17\";",
        "      color.muted = \"#6a6258\";",
        "      color.accent = \"#0c7f7a\";",
        "    }",
        "  }",
      ].join("\n")
    : "";

  const assetsBlock = options.assets
    ? [
        "  /// Asset banks let you reference local media by id.",
        "  assets {",
        "    // Asset bank for local images. Drop files into ./assets.",
        "    bank media {",
        "      kind = image;",
        "      root = \"assets\";",
        "      include = \"*.{png,jpg,jpeg,svg}\";",
        "      strategy = uniform;",
        "    }",
        "  }",
      ].join("\n")
    : "";

  return [
    "/// Flux document starter generated by `flux new`.",
    "/// Edit meta.title, pageConfig, tokens, and the body sections below.",
    "document {",
    "  meta {",
    "    /// Human-readable title for exports and viewer tabs.",
    `    title = \"${escapeString(options.title)}\";`,
    "    version = \"0.3.0\";",
    "    /// Screen is the base target; print theme is optional.",
    `    target = \"${target}\";`,
    "  }",
    "",
    "  /// Page size and units for layout.",
    "  pageConfig {",
    "    size {",
    `      width = ${size.width};`,
    `      height = ${size.height};`,
    `      units = \"${size.units}\";`,
    "    }",
    "  }",
    "",
    "  /// Design tokens drive typography, color, and spacing.",
    "  tokens {",
    "    /// Font stacks include fallbacks unless disabled.",
    `    font.body = \"${fontBody}\";`,
    `    font.heading = \"${fontHeading}\";`,
    `    font.mono = \"${fontMono}\";`,
    "    color.text = \"#1d1b17\";",
    "    color.muted = \"#6b645a\";",
    "    color.accent = \"#0ea5a4\";",
    "    color.link = \"#2b4c7e\";",
    "    color.calloutBg = \"#f6f1e8\";",
    "    color.calloutBorder = \"#d9d0c4\";",
    "    space.xs = 2;",
    "    space.s = 4;",
    "    space.m = 8;",
    "    space.l = 12;",
    "    space.xl = 18;",
    "  }",
    "",
    "  /// Style presets referenced by text nodes.",
    "  styles {",
    "    Body {",
    "      font.family = @tokens.font.body;",
    "      font.size = 11;",
    "      line.height = 1.45;",
    "      color = @tokens.color.text;",
    "      space.after = @tokens.space.m;",
    "    }",
    "    H1 : Body {",
    "      font.family = @tokens.font.heading;",
    "      font.size = 18;",
    "      font.weight = 600;",
    "      space.before = @tokens.space.m;",
    "      space.after = @tokens.space.s;",
    "    }",
    "    H2 : Body {",
    "      font.family = @tokens.font.heading;",
    "      font.size = 14;",
    "      font.weight = 600;",
    "      space.before = @tokens.space.s;",
    "      space.after = @tokens.space.xs;",
    "    }",
    "    Title : H1 {",
    "      font.size = 26;",
    "      letter.spacing = \"0.02em\";",
    "      space.after = @tokens.space.s;",
    "    }",
    "    Subtitle : Body {",
    "      color = @tokens.color.muted;",
    "      font.size = 12;",
    "      space.after = @tokens.space.m;",
    "    }",
    "    Lead : Body {",
    "      font.size = 12;",
    "      line.height = 1.55;",
    "      space.after = @tokens.space.m;",
    "    }",
    "    Byline : Body {",
    "      font.size = 10;",
    "      color = @tokens.color.muted;",
    "      space.after = @tokens.space.s;",
    "    }",
    "    Abstract : Body {",
    "      font.size = 11;",
    "      font.style = \"italic\";",
    "      space.after = @tokens.space.m;",
    "    }",
    "    Keywords : Body {",
    "      font.size = 9.5;",
    "      color = @tokens.color.muted;",
    "      space.after = @tokens.space.s;",
    "    }",
    "    Caption : Body {",
    "      font.size = 9.5;",
    "      color = @tokens.color.muted;",
    "    }",
    "    Credit : Body {",
    "      font.size = 9;",
    "      color = @tokens.color.muted;",
    "    }",
    "    Quote : Body {",
    "      font.style = \"italic\";",
    "      background = @tokens.color.calloutBg;",
    "      border = \"1pt solid #d9d0c4\";",
    "      padding = @tokens.space.s;",
    "      space.before = @tokens.space.s;",
    "      space.after = @tokens.space.s;",
    "    }",
    "    Callout : Body {",
    "      background = @tokens.color.calloutBg;",
    "      border = \"1pt solid #d9d0c4\";",
    "      border.radius = 6;",
    "      padding = @tokens.space.s;",
    "      space.before = @tokens.space.s;",
    "      space.after = @tokens.space.s;",
    "    }",
    "    Code : Body {",
    "      font.family = @tokens.font.mono;",
    "      font.size = 9.5;",
    "      background = \"#f4f0e9\";",
    "      padding = @tokens.space.s;",
    "      border.radius = 6;",
    "    }",
    "  }",
    themeBlock,
    assetsBlock,
    extraBlocks.join("\n"),
    "",
    "  /// Pages, sections, and content blocks.",
    "  body {",
    indent(bodyContent, 2),
    "  }",
    "}",
    "",
  ]
    .filter((line) => line !== undefined)
    .join("\n");
}

function buildBlankTemplate(options: TemplateOptions): TemplateOutput {
  const body = [
    "page main {",
    "  section intro {",
    "    // Start building your document.",
    "    text title {",
    "      style = \"Title\";",
    "      content = @meta.title;",
    "    }",
    "  }",
    "}",
  ].join("\n");

  return {
    mainFlux: buildBaseDoc(options, body, []),
    readme: [
      "# Flux Blank Document",
      "",
      "This is a minimal Flux document starter.",
      "",
      "Next steps:",
      "- Update meta.title and tokens in the .flux file.",
      "- Add sections, figures, and callouts as needed.",
      "- Run `flux view` to open the live viewer.",
      "",
    ].join("\n"),
    chapters: [],
    assetsDir: options.assets ? "assets" : undefined,
  };
}

function buildDemoTemplate(options: TemplateOptions): TemplateOutput {
  const liveContent = options.live
    ? [
        "text liveLabel { style = \"H2\"; content = \"Live slots\"; }",
        "text liveBody {",
        "  content = \"Docstep: \";",
        "  inline_slot liveStep {",
        "    reserve = fixedWidth(6, ch);",
        "    fit = ellipsis;",
        "    refresh = docstep;",
        "    text liveValue { content = @docstep; }",
        "  }",
        "  text liveTail { content = \" - time \"; }",
        "  inline_slot liveTime {",
        "    reserve = fixedWidth(6, ch);",
        "    fit = ellipsis;",
        "    refresh = docstep;",
        "    text liveTimeValue { content = @time; }",
        "  }",
        "  text liveTail2 { content = \"s\"; }",
        "}",
      ].join("\n")
    : [
        "text liveLabel { style = \"H2\"; content = \"Static snapshot\"; }",
        "text liveBody { content = \"Live slots disabled. Flip the setting to enable.\"; }",
      ].join("\n");

  const liveSection = [
    "  section liveSlots {",
    indent(liveContent, 4),
    "  }",
  ].join("\n");

  const assetsContent = options.assets
    ? [
        "figure demoFigure {",
        "  label = \"fig:assets\";",
        "  slot demoSlot {",
        "    reserve = fixed(340, 200, px);",
        "    fit = scaleDown;",
        "    refresh = docstep;",
        "    image demoImage { asset = @assets.pick(noRepeatSteps=2); }",
        "  }",
        "  text demoCaption { role = \"caption\"; content = \"Figure pulls from ./assets using assets.pick.\"; }",
        "  text demoCredit { role = \"credit\"; content = \"Drop images into ./assets to swap.\"; }",
        "}",
      ].join("\n")
    : [
        "slot demoSlot {",
        "  reserve = fixed(340, 200, px);",
        "  fit = scaleDown;",
        "  text demoSlotText { content = \"Enable assets to drop images here.\"; }",
        "}",
        "text demoNote { style = \"Caption\"; content = \"Assets are disabled for this scaffold.\"; }",
      ].join("\n");

  const assetsSection = [
    "  section assetsDemo {",
    "    text assetsHeading { style = \"H1\"; content = \"Assets + slots\"; }",
    indent(assetsContent, 4),
    "  }",
  ].join("\n");

  const body = [
    "page cover {",
    "  /// Update the title + subtitle below.",
    "  section hero {",
    `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
    "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"A 2026 demo for Flux\"; }",
    "    text byline { role = \"byline\"; content = \"Prepared with flux new\"; }",
    "  }",
    "  section summary {",
    "    text summaryHeading { style = \"H1\"; content = \"What to edit next\"; }",
    "    text summaryBody { content = \"Replace these paragraphs, tweak styles, and wire assets.\"; }",
    "    ul summaryList {",
    "      li step1 { text step1Text { content = \"Update meta.title and pageConfig.\"; } }",
    "      li step2 { text step2Text { content = \"Swap fonts and colors in tokens.\"; } }",
    "      li step3 { text step3Text { content = \"Drop imagery into assets and re-run flux view.\"; } }",
    "    }",
    "  }",
    "}",
    "page toolkit {",
    "  section layout {",
    "    text layoutHeading { style = \"H1\"; content = \"Layout primitives\"; }",
    "    row layoutRow {",
    "      column layoutLeft {",
    "        text layoutBody { content = \"Compose pages with rows, columns, and sections. Use slots for live updates.\"; }",
    "        text layoutBody2 { content = \"Keep content deterministic while assets and data evolve.\"; }",
    "      }",
    "      column layoutRight {",
    "        callout layoutCallout {",
    "          tone = \"note\";",
    "          text calloutText { content = \"Sections are the main narrative blocks. Rows and columns help compose grids.\"; }",
    "        }",
    "      }",
    "    }",
    "  }",
    liveSection,
    assetsSection,
    "}",
    ...buildChapterIncludes(options.chapters),
  ].join("\n");

  return {
    mainFlux: buildBaseDoc(options, body),
    readme: buildReadme(options),
    chapters: buildChapters(options.chapters),
    assetsDir: options.assets ? "assets" : undefined,
  };
}

function buildArticleTemplate(options: TemplateOptions): TemplateOutput {
  const body = [
    "page cover {",
    "  section hero {",
    `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
    "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"A narrative article starter\"; }",
    "    text byline { role = \"byline\"; content = \"By Your Name\"; }",
    "    text deck { style = \"Lead\"; content = \"Write a crisp, curiosity-driven lead that frames the story.\"; }",
    "  }",
    "  section opener {",
    "    text openerHeading { style = \"H1\"; content = \"Opening\"; }",
    "    text openerBody { content = \"Set the scene with a concrete moment, then broaden to the stakes.\"; }",
    "  }",
    "}",
    "page story {",
    "  section context {",
    "    text contextHeading { style = \"H1\"; content = \"Context\"; }",
    "    text contextBody { content = \"Add background, quotes, and data points that anchor the reader.\"; }",
    "  }",
    "  section pullQuote {",
    "    blockquote quoteBlock { text quoteText { content = \"A single resonant line can carry the chapter.\"; } }",
    "  }",
    "  section keyPoints {",
    "    text keyHeading { style = \"H2\"; content = \"Key points\"; }",
    "    ul keyList {",
    "      li key1 { text key1Text { content = \"Introduce the main character or idea.\"; } }",
    "      li key2 { text key2Text { content = \"Add one surprising detail.\"; } }",
    "      li key3 { text key3Text { content = \"Close with the forward-looking question.\"; } }",
    "    }",
    "  }",
    "  callout sidebar {",
    "    tone = \"info\";",
    "    text sidebarText { content = \"Use callouts for sidebars, stats, or editor notes.\"; }",
    "  }",
    "}",
    ...buildChapterIncludes(options.chapters),
  ].join("\n");

  return {
    mainFlux: buildBaseDoc(options, body),
    readme: buildReadme(options),
    chapters: buildChapters(options.chapters),
    assetsDir: options.assets ? "assets" : undefined,
  };
}

function buildSpecTemplate(options: TemplateOptions): TemplateOutput {
  const body = [
    "page overview {",
    "  section header {",
    `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
    "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"Specification draft\"; }",
    "    text byline { role = \"byline\"; content = \"Owner: Team Flux\"; }",
    "  }",
    "  section summary {",
    "    text summaryHeading { style = \"H1\"; content = \"Summary\"; }",
    "    text summaryBody { content = \"Describe the problem, the proposed solution, and the intended outcomes.\"; }",
    "  }",
    "  section goals {",
    "    text goalsHeading { style = \"H2\"; content = \"Goals\"; }",
    "    ul goalsList {",
    "      li goal1 { text goal1Text { content = \"Clarify scope and success criteria.\"; } }",
    "      li goal2 { text goal2Text { content = \"Define the primary user experience.\"; } }",
    "      li goal3 { text goal3Text { content = \"Document tradeoffs and constraints.\"; } }",
    "    }",
    "  }",
    "}",
    "page requirements {",
    "  section requirements {",
    "    text reqHeading { style = \"H1\"; content = \"Requirements\"; }",
    "    text reqBody { content = \"List functional and non-functional requirements.\"; }",
    "    table reqTable {",
    "      rows = [",
    "        [\"ID\", \"Requirement\", \"Priority\"],",
    "        [\"REQ-1\", \"Describe the core behavior\", \"P0\"],",
    "        [\"REQ-2\", \"Define error handling\", \"P1\"],",
    "        [\"REQ-3\", \"Document limits and scale\", \"P1\"]",
    "      ];",
    "      header = true;",
    "    }",
    "  }",
    "  callout constraints {",
    "    tone = \"note\";",
    "    text constraintsText { content = \"Capture constraints: latency, size, and security expectations.\"; }",
    "  }",
    "}",
    "page api {",
    "  section api {",
    "    text apiHeading { style = \"H1\"; content = \"API sketch\"; }",
    "    codeblock apiBlock { content = \"GET /api/status\\nPOST /api/update\"; }",
    "  }",
    "  section rollout {",
    "    text rolloutHeading { style = \"H2\"; content = \"Rollout\"; }",
    "    ol rolloutList {",
    "      li r1 { text r1Text { content = \"Prototype and verify behavior.\"; } }",
    "      li r2 { text r2Text { content = \"Ship behind a flag to pilot users.\"; } }",
    "      li r3 { text r3Text { content = \"Measure adoption and iterate.\"; } }",
    "    }",
    "  }",
    "}",
    ...buildChapterIncludes(options.chapters),
  ].join("\n");

  return {
    mainFlux: buildBaseDoc(options, body),
    readme: buildReadme(options),
    chapters: buildChapters(options.chapters),
    assetsDir: options.assets ? "assets" : undefined,
  };
}

function buildZineTemplate(options: TemplateOptions): TemplateOutput {
  const body = [
    "page splash {",
    "  section masthead {",
    `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
    "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"Visual zine layout\"; }",
    "    text byline { role = \"byline\"; content = \"Issue 01\"; }",
    "  }",
    "  section opener {",
    "    text openerHeading { style = \"H1\"; content = \"Theme\"; }",
    "    text openerBody { content = \"Set the mood with a short manifesto or editor note.\"; }",
    "  }",
    "}",
    "page collage {",
    "  section spread {",
    "    text spreadHeading { style = \"H1\"; content = \"Collage spread\"; }",
    "    row highlights {",
    "      column left {",
    "        text leftHeading { style = \"H2\"; content = \"Left column\"; }",
    "        text leftBody { content = \"Short bites, captions, and pull quotes.\"; }",
    "        slot leftSlot {",
    "          reserve = fixed(220, 140, px);",
    "          fit = scaleDown;",
    "          text leftSlotText { content = \"Drop art here.\"; }",
    "        }",
    "      }",
    "      column right {",
    "        text rightHeading { style = \"H2\"; content = \"Right column\"; }",
    "        text rightBody { content = \"Add illustration or collage notes.\"; }",
    "        callout zineCallout {",
    "          tone = \"note\";",
    "          text calloutText { content = \"Use callouts for side notes or credits.\"; }",
    "        }",
    "      }",
    "    }",
    "  }",
    "}",
    "page backcover {",
    "  section notes {",
    "    text notesHeading { style = \"H1\"; content = \"Back cover\"; }",
    "    text notesBody { content = \"Add credits, links, or closing remarks.\"; }",
    "    ul notesList {",
    "      li note1 { text note1Text { content = \"Credits and contributors\"; } }",
    "      li note2 { text note2Text { content = \"Release notes or version info\"; } }",
    "      li note3 { text note3Text { content = \"Contact and next issue\"; } }",
    "    }",
    "  }",
    "}",
    ...buildChapterIncludes(options.chapters),
  ].join("\n");

  return {
    mainFlux: buildBaseDoc(options, body),
    readme: buildReadme(options),
    chapters: buildChapters(options.chapters),
    assetsDir: options.assets ? "assets" : undefined,
  };
}

function buildPaperTemplate(options: TemplateOptions): TemplateOutput {
  const body = [
    "page title {",
    "  section titleBlock {",
    `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
    "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"Abstract + references\"; }",
    "    text byline { role = \"byline\"; content = \"Author Name, Affiliation\"; }",
    "  }",
    "  section abstract {",
    "    text abstractHeading { style = \"H2\"; content = \"Abstract\"; }",
    "    text abstractBody { role = \"abstract\"; content = \"Summarize the contribution in 3-4 sentences.\"; }",
    "    text keywords { role = \"keywords\"; content = \"Keywords: flux, layout, rendering\"; }",
    "  }",
    "}",
    "page methods {",
    "  section methodsBlock {",
    "    text methodsHeading { style = \"H1\"; content = \"Methods\"; }",
    "    text methodsBody { content = \"Describe the experimental setup or methodology.\"; }",
    "    table methodsTable {",
    "      rows = [",
    "        [\"Step\", \"Description\"],",
    "        [\"1\", \"Collect input data\"],",
    "        [\"2\", \"Run the core algorithm\"],",
    "        [\"3\", \"Evaluate outcomes\"]",
    "      ];",
    "      header = true;",
    "    }",
    "  }",
    "}",
    "page results {",
    "  section resultsBlock {",
    "    text resultsHeading { style = \"H1\"; content = \"Results\"; }",
    "    text resultsBody { content = \"Summarize findings and highlight key metrics.\"; }",
    "    figure resultsFigure {",
    "      label = \"fig:results\";",
    "      slot resultsSlot {",
    "        reserve = fixed(320, 200, px);",
    "        fit = scaleDown;",
    "        text resultsSlotText { content = \"Add a chart or diagram.\"; }",
    "      }",
    "      text resultsCaption { role = \"caption\"; content = \"Figure 1. Primary results.\"; }",
    "    }",
    "  }",
    "}",
    "page references {",
    "  section referencesBlock {",
    "    text refHeading { style = \"H1\"; content = \"References\"; }",
    "    ol refList {",
    "      li ref1 { text ref1Text { content = \"Author, Title, Year\"; } }",
    "      li ref2 { text ref2Text { content = \"Author, Title, Year\"; } }",
    "      li ref3 { text ref3Text { content = \"Author, Title, Year\"; } }",
    "    }",
    "  }",
    "}",
    ...buildChapterIncludes(options.chapters),
  ].join("\n");

  return {
    mainFlux: buildBaseDoc(options, body),
    readme: buildReadme(options),
    chapters: buildChapters(options.chapters),
    assetsDir: options.assets ? "assets" : undefined,
  };
}

function buildReadme(options: TemplateOptions): string {
  return [
    "# Flux Document",
    "",
    "This folder was generated by `flux new`.",
    "Use it as a starting point for a Flux document or layout experiment.",
    "",
    "## Files",
    "- `<doc>.flux` is the main document source.",
    "- `README.md` (this file) explains the scaffold.",
    options.assets ? "- `assets/` is ready for local images." : "- `assets/` was not created.",
    options.chapters > 0
      ? "- `chapters/` contains chapter fragments included by the main document."
      : "- `chapters/` was not created.",
    "",
    "## Editing basics",
    "- Update `meta.title` for the document name.",
    "- Tweak `pageConfig` for size and units.",
    "- Adjust `tokens` to change fonts, colors, and spacing.",
    "- Update `styles` to restyle headings, captions, and body text.",
    "- Add or reorder content inside the `body` block.",
    options.chapters > 0
      ? "- Chapter fragments are included via `page chapterX` blocks in the main document."
      : "",
    "",
    "## Preview and export",
    "- Run `flux view <doc>.flux` to launch the viewer.",
    "- Run `flux check <doc>.flux` for static checks.",
    "- Run `flux pdf <doc>.flux --out output.pdf` for a snapshot.",
    "",
    "## Options used",
    `Title: ${options.title}`,
    `Page size: ${options.page}`,
    `Theme: ${options.theme}`,
    `Fonts: ${options.fonts}`,
    `Font fallback: ${options.fontFallback === "none" ? "primary only" : "system stack"}`,
    `Assets: ${options.assets ? "enabled" : "disabled"}`,
    `Chapters: ${options.chapters > 0 ? options.chapters : "none"}`,
    `Live slots: ${options.live ? "enabled" : "disabled"}`,
    "",
  ].join("\n");
}

function buildChapters(count: number): { path: string; content: string }[] {
  const chapters: { path: string; content: string }[] = [];
  for (let i = 1; i <= count; i += 1) {
    const name = `chapter-${i}.flux`;
    const content = [
      "/// Chapter fragment generated by `flux new`.",
      "/// This file is included by the main document.",
      "document {",
      "  meta {",
      "    version = \"0.3.0\";",
      "  }",
      "  body {",
      `    section chapter${i} {`,
      `      text heading { style = \"H2\"; content = \"Chapter ${i}\"; }`,
      "      text body { content = \"Edit this chapter fragment to build the section.\"; }",
      "      callout chapterNote {",
      "        tone = \"note\";",
      "        text noteBody { content = \"Keep chapter sections modular and focused.\"; }",
      "      }",
      "    }",
      "  }",
      "}",
      "",
    ].join("\n");
    chapters.push({ path: name, content });
  }
  return chapters;
}

function buildChapterIncludes(count: number): string[] {
  if (count <= 0) return [];
  const lines = ["", "/// Chapter pages (includes fragments from ./chapters)"];
  for (let i = 1; i <= count; i += 1) {
    lines.push(`page chapter${i} {`);
    lines.push(`  include chapter${i} { path = \"chapters/chapter-${i}.flux\"; }`);
    lines.push("}");
  }
  return lines;
}

function formatFontStack(font: FontStack, fallback: FontFallbackOption): string {
  if (fallback === "none") return font.primary;
  return `${font.primary}, ${font.fallback}`;
}

function indent(text: string, level: number): string {
  const prefix = "  ".repeat(level);
  return text
    .split("\n")
    .map((line) => (line.length ? prefix + line : ""))
    .join("\n");
}

function escapeString(value: string): string {
  return value.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"");
}

export function stripTrailingCommasInLists(text: string): string {
  let result = "";
  let inString = false;
  let inLineComment = false;

  const findNextSignificantChar = (start: number): string | null => {
    for (let i = start; i < text.length; i += 1) {
      const ch = text[i];
      if (ch === " " || ch === "\t" || ch === "\n" || ch === "\r") {
        continue;
      }
      if (ch === "/" && text[i + 1] === "/") {
        i += 2;
        for (; i < text.length; i += 1) {
          if (text[i] === "\n") {
            break;
          }
        }
        continue;
      }
      return ch;
    }
    return null;
  };

  for (let i = 0; i < text.length; i += 1) {
    const ch = text[i];

    if (inLineComment) {
      result += ch;
      if (ch === "\n") {
        inLineComment = false;
      }
      continue;
    }

    if (inString) {
      result += ch;
      if (ch === "\\") {
        if (i + 1 < text.length) {
          result += text[i + 1];
          i += 1;
        }
        continue;
      }
      if (ch === "\"") {
        inString = false;
      }
      continue;
    }

    if (ch === "\"") {
      inString = true;
      result += ch;
      continue;
    }

    if (ch === "/" && text[i + 1] === "/") {
      inLineComment = true;
      result += ch;
      result += text[i + 1];
      i += 1;
      continue;
    }

    if (ch === ",") {
      const next = findNextSignificantChar(i + 1);
      if (next === "]") {
        continue;
      }
    }

    result += ch;
  }

  return result;
}
