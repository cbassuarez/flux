const FONT_PRESETS = {
    tech: {
        body: { primary: "Inter", fallback: "Helvetica Neue, Arial, sans-serif" },
        heading: { primary: "IBM Plex Sans", fallback: "Inter, Helvetica Neue, Arial, sans-serif" },
        mono: { primary: "JetBrains Mono", fallback: "Source Code Pro, Menlo, monospace" },
    },
    bookish: {
        body: { primary: "Iowan Old Style", fallback: "Palatino Linotype, Palatino, Times New Roman, serif" },
        heading: { primary: "Iowan Old Style", fallback: "Palatino Linotype, Palatino, Times New Roman, serif" },
        mono: { primary: "Source Code Pro", fallback: "Courier New, monospace" },
    },
};
const PAGE_SIZES = {
    Letter: { width: 8.5, height: 11, units: "in" },
    A4: { width: 210, height: 297, units: "mm" },
};
export function getTemplate(name) {
    const templates = [
        {
            name: "demo",
            description: "Live slots + assets + annotations",
            build: buildDemoTemplate,
        },
        {
            name: "article",
            description: "Narrative article starter",
            build: buildArticleTemplate,
        },
        {
            name: "spec",
            description: "Technical spec layout",
            build: buildSpecTemplate,
        },
        {
            name: "zine",
            description: "Visual zine layout",
            build: buildZineTemplate,
        },
        {
            name: "paper",
            description: "Academic paper with abstract",
            build: buildPaperTemplate,
        },
    ];
    return templates.find((t) => t.name === name) ?? null;
}
function buildBaseDoc(options, bodyContent, extraBlocks = []) {
    const size = PAGE_SIZES[options.page];
    const fonts = FONT_PRESETS[options.fonts];
    const fontBody = formatFontStack(fonts.body, options.fontFallback);
    const fontHeading = formatFontStack(fonts.heading, options.fontFallback);
    const fontMono = formatFontStack(fonts.mono, options.fontFallback);
    const target = options.theme === "both" ? "screen" : options.theme;
    const themeBlock = options.theme !== "screen"
        ? [
            "  /// Optional print theme overrides for exports.",
            "  theme \"print\" {",
            "    tokens {",
            "      color.text = \"#1b1a17\";",
            "      color.muted = \"#6a6258\";",
            "      color.accent = \"#0c7f7a\";",
            "    }",
            "  }",
        ].join("\n")
        : "";
    const assetsBlock = options.assets
        ? [
            "  /// Asset banks let you reference local media by id.",
            "  assets {",
            "    // Asset bank for local images. Drop files into ./assets.",
            "    bank media {",
            "      kind = image;",
            "      root = \"assets\";",
            "      include = \"*.{png,jpg,jpeg,svg}\";",
            "      strategy = uniform;",
            "    }",
            "  }",
        ].join("\n")
        : "";
    return [
        "/// Flux document starter generated by `flux new`.",
        "/// Edit meta.title, pageConfig, tokens, and the body sections below.",
        "document {",
        "  meta {",
        "    /// Human-readable title for exports and viewer tabs.",
        `    title = \"${escapeString(options.title)}\";`,
        "    version = \"0.3.0\";",
        "    /// Screen is the base target; print theme is optional.",
        `    target = \"${target}\";`,
        "  }",
        "",
        "  /// Page size and units for layout.",
        "  pageConfig {",
        "    size {",
        `      width = ${size.width};`,
        `      height = ${size.height};`,
        `      units = \"${size.units}\";`,
        "    }",
        "  }",
        "",
        "  /// Design tokens drive typography, color, and spacing.",
        "  tokens {",
        "    /// Font stacks include fallbacks unless disabled.",
        `    font.body = \"${fontBody}\";`,
        `    font.heading = \"${fontHeading}\";`,
        `    font.mono = \"${fontMono}\";`,
        "    color.text = \"#1d1b17\";",
        "    color.muted = \"#6b645a\";",
        "    color.accent = \"#0ea5a4\";",
        "    space.xs = 2;",
        "    space.s = 4;",
        "    space.m = 8;",
        "    space.l = 12;",
        "    space.xl = 18;",
        "  }",
        "",
        "  /// Style presets referenced by text nodes.",
        "  styles {",
        "    Body {",
        "      font.family = @tokens.font.body;",
        "      font.size = 11;",
        "      line.height = 1.45;",
        "      color = @tokens.color.text;",
        "      space.after = @tokens.space.m;",
        "    }",
        "    H1 : Body {",
        "      font.family = @tokens.font.heading;",
        "      font.size = 18;",
        "      font.weight = 600;",
        "      space.before = @tokens.space.m;",
        "      space.after = @tokens.space.s;",
        "    }",
        "    H2 : Body {",
        "      font.family = @tokens.font.heading;",
        "      font.size = 14;",
        "      font.weight = 600;",
        "      space.before = @tokens.space.s;",
        "      space.after = @tokens.space.xs;",
        "    }",
        "    Title : H1 {",
        "      font.size = 26;",
        "      letter.spacing = \"0.02em\";",
        "      space.after = @tokens.space.s;",
        "    }",
        "    Subtitle : Body {",
        "      color = @tokens.color.muted;",
        "      font.size = 12;",
        "      space.after = @tokens.space.m;",
        "    }",
        "    Caption : Body {",
        "      font.size = 9.5;",
        "      color = @tokens.color.muted;",
        "    }",
        "    Code : Body {",
        "      font.family = @tokens.font.mono;",
        "      font.size = 9.5;",
        "      background = \"#f4f0e9\";",
        "      padding = @tokens.space.s;",
        "      border.radius = 6;",
        "    }",
        "  }",
        themeBlock,
        assetsBlock,
        extraBlocks.join("\n"),
        "",
        "  /// Pages, sections, and content blocks.",
        "  body {",
        indent(bodyContent, 2),
        "  }",
        "}",
        "",
    ]
        .filter((line) => line !== undefined)
        .join("\n");
}
function buildDemoTemplate(options) {
    const liveLine = options.live
        ? [
            "text liveLabel { style = \"H2\"; content = \"Live slots\"; }",
            "text liveBody {",
            "  content = \"Docstep: \";",
            "  inline_slot liveStep {",
            "    reserve = fixedWidth(6, ch);",
            "    fit = ellipsis;",
            "    refresh = onDocstep;",
            "    text liveValue { content = @docstep; }",
            "  }",
            "  text liveTail { content = \" - time \"; }",
            "  inline_slot liveTime {",
            "    reserve = fixedWidth(6, ch);",
            "    fit = ellipsis;",
            "    refresh = onDocstep;",
            "    text liveTimeValue { content = @time; }",
            "  }",
            "  text liveTail2 { content = \"s\"; }",
            "}",
        ].join("\n")
        : [
            "text liveLabel { style = \"H2\"; content = \"Static snapshot\"; }",
            "text liveBody { content = \"Live slots disabled. Flip the setting to enable.\"; }",
        ].join("\n");
    const body = [
        "page cover {",
        "  /// Update the title + subtitle below.",
        "  section hero {",
        `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
        "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"A 2026 demo for Flux\"; }",
        "    text byline { content = \"Prepared with flux new\"; }",
        "  }",
        "  section summary {",
        "    text summaryHeading { style = \"H1\"; content = \"What to edit next\"; }",
        "    text summaryBody { content = \"Replace these paragraphs, tweak styles, and wire assets.\"; }",
        "  }",
        indent(liveLine, 2),
        "  section demoActions {",
        "    text demoHeading { style = \"H1\"; content = \"Assets + slots\"; }",
        "    slot demoSlot {",
        "      reserve = fixed(260, 120, px);",
        "      fit = scaleDown;",
        "      refresh = onDocstep;",
        "      text demoSlotText { content = \"Drop a figure or image here.\"; }",
        "    }",
        "  }",
        "}",
        ...buildChapterIncludes(options.chapters),
    ].join("\n");
    return {
        mainFlux: buildBaseDoc(options, body),
        readme: buildReadme(options),
        chapters: buildChapters(options.chapters),
        assetsDir: options.assets ? "assets" : undefined,
    };
}
function buildArticleTemplate(options) {
    const body = [
        "page article {",
        "  section lead {",
        `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
        "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"Short deck for the story.\"; }",
        "  }",
        "  section intro {",
        "    text introHeading { style = \"H1\"; content = \"Introduction\"; }",
        "    text introBody { content = \"Open with a strong paragraph that sets context.\"; }",
        "  }",
        "  section body {",
        "    text bodyHeading { style = \"H1\"; content = \"Main section\"; }",
        "    text bodyText { content = \"Add narrative content, quotes, and figures.\"; }",
        "  }",
        "}",
        ...buildChapterIncludes(options.chapters),
    ].join("\n");
    return {
        mainFlux: buildBaseDoc(options, body),
        readme: buildReadme(options),
        chapters: buildChapters(options.chapters),
        assetsDir: options.assets ? "assets" : undefined,
    };
}
function buildSpecTemplate(options) {
    const body = [
        "page spec {",
        "  section overview {",
        `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
        "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"Specification draft\"; }",
        "  }",
        "  section requirements {",
        "    text reqHeading { style = \"H1\"; content = \"Requirements\"; }",
        "    text reqBody { content = \"List functional and non-functional requirements.\"; }",
        "    table reqTable {",
        "      rows = [",
        "        [\"ID\", \"Requirement\"],",
        "        [\"REQ-1\", \"Describe the core behavior\"],",
        "      ];",
        "      header = true;",
        "    }",
        "  }",
        "  section api {",
        "    text apiHeading { style = \"H1\"; content = \"API sketch\"; }",
        "    codeblock apiBlock { content = \"GET /api/status\\nPOST /api/update\"; }",
        "  }",
        "}",
        ...buildChapterIncludes(options.chapters),
    ].join("\n");
    return {
        mainFlux: buildBaseDoc(options, body),
        readme: buildReadme(options),
        chapters: buildChapters(options.chapters),
        assetsDir: options.assets ? "assets" : undefined,
    };
}
function buildZineTemplate(options) {
    const body = [
        "page zine {",
        "  section splash {",
        `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
        "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"Visual zine layout\"; }",
        "  }",
        "  row highlights {",
        "    column left {",
        "      text leftHeading { style = \"H2\"; content = \"Left column\"; }",
        "      text leftBody { content = \"Short bites and captions.\"; }",
        "    }",
        "    column right {",
        "      text rightHeading { style = \"H2\"; content = \"Right column\"; }",
        "      text rightBody { content = \"Add illustration or collage.\"; }",
        "    }",
        "  }",
        "  callout zineCallout {",
        "    tone = \"note\";",
        "    text calloutText { content = \"Use callouts for side notes.\"; }",
        "  }",
        "}",
        ...buildChapterIncludes(options.chapters),
    ].join("\n");
    return {
        mainFlux: buildBaseDoc(options, body),
        readme: buildReadme(options),
        chapters: buildChapters(options.chapters),
        assetsDir: options.assets ? "assets" : undefined,
    };
}
function buildPaperTemplate(options) {
    const body = [
        "page paper {",
        "  section titleBlock {",
        `    text title { role = \"title\"; style = \"Title\"; content = \"${escapeString(options.title)}\"; }`,
        "    text subtitle { role = \"subtitle\"; style = \"Subtitle\"; content = \"Abstract + references\"; }",
        "  }",
        "  section abstract {",
        "    text abstractHeading { style = \"H2\"; content = \"Abstract\"; }",
        "    text abstractBody { content = \"Summarize the contribution.\"; }",
        "  }",
        "  section main {",
        "    text mainHeading { style = \"H1\"; content = \"Main section\"; }",
        "    text mainBody { content = \"Describe methods and results.\"; }",
        "  }",
        "  section references {",
        "    text refHeading { style = \"H2\"; content = \"References\"; }",
        "    text refBody { content = \"Add citations or a bibliography list.\"; }",
        "  }",
        "}",
        ...buildChapterIncludes(options.chapters),
    ].join("\n");
    return {
        mainFlux: buildBaseDoc(options, body),
        readme: buildReadme(options),
        chapters: buildChapters(options.chapters),
        assetsDir: options.assets ? "assets" : undefined,
    };
}
function buildReadme(options) {
    return [
        "# Flux Document",
        "",
        "This folder was generated by `flux new`.",
        "Use it as a starting point for a Flux document or layout experiment.",
        "",
        "## Files",
        "- `<doc>.flux` is the main document source.",
        "- `README.md` (this file) explains the scaffold.",
        options.assets ? "- `assets/` is ready for local images." : "- `assets/` was not created.",
        options.chapters > 0 ? "- `chapters/` contains chapter stubs." : "- `chapters/` was not created.",
        "",
        "## Editing basics",
        "- Update `meta.title` for the document name.",
        "- Tweak `pageConfig` for size and units.",
        "- Adjust `tokens` to change fonts, colors, and spacing.",
        "- Update `styles` to restyle headings, captions, and body text.",
        "- Add or reorder content inside the `body` block.",
        "",
        "## Preview and export",
        "- Run `flux view <doc>.flux` to launch the viewer.",
        "- Run `flux check <doc>.flux` for static checks.",
        "- Run `flux pdf <doc>.flux --out output.pdf` for a snapshot.",
        "",
        "## Options used",
        `Title: ${options.title}`,
        `Page size: ${options.page}`,
        `Theme: ${options.theme}`,
        `Fonts: ${options.fonts}`,
        `Font fallback: ${options.fontFallback === "none" ? "primary only" : "system stack"}`,
        `Assets: ${options.assets ? "enabled" : "disabled"}`,
        `Chapters: ${options.chapters > 0 ? options.chapters : "none"}`,
        `Live slots: ${options.live ? "enabled" : "disabled"}`,
        "",
    ].join("\n");
}
function buildChapters(count) {
    const chapters = [];
    for (let i = 1; i <= count; i += 1) {
        const name = `chapter-${i}.flux`;
        const content = [
            "/// Chapter stub generated by `flux new`.",
            "document {",
            "  meta {",
            "    version = \"0.3.0\";",
            "  }",
            "  body {",
            `    section chapter${i} {`,
            `      text heading { style = \"H2\"; content = \"Chapter ${i}\"; }`,
            "      text body { content = \"Edit this chapter file.\"; }",
            "    }",
            "  }",
            "}",
            "",
        ].join("\n");
        chapters.push({ path: name, content });
    }
    return chapters;
}
function buildChapterIncludes(count) {
    if (count <= 0)
        return [];
    const lines = ["", "/// Chapter includes"];
    for (let i = 1; i <= count; i += 1) {
        lines.push(`include chapter${i} { path = \"chapters/chapter-${i}.flux\"; }`);
    }
    return lines;
}
function formatFontStack(font, fallback) {
    if (fallback === "none")
        return font.primary;
    return `${font.primary}, ${font.fallback}`;
}
function indent(text, level) {
    const prefix = "  ".repeat(level);
    return text
        .split("\n")
        .map((line) => (line.length ? prefix + line : ""))
        .join("\n");
}
function escapeString(value) {
    return value.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"");
}
//# sourceMappingURL=templates.js.map