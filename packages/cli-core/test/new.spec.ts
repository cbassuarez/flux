import { describe, it, expect } from "vitest";
import { mkdtemp, readFile, access } from "node:fs/promises";
import { tmpdir } from "node:os";
import { dirname, join } from "node:path";
import { parseDocument } from "@flux-lang/core";
import { newCommand } from "../src/commands/new.js";
import type { TemplateName } from "../src/new/templates.js";

async function exists(path: string): Promise<boolean> {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

describe("cli-core newCommand", () => {
  it("creates files, README, assets, and chapters", async () => {
    const cwd = await mkdtemp(join(tmpdir(), "flux-new-"));
    const result = await newCommand({
      cwd,
      template: "demo",
      out: cwd,
      page: "A4",
      theme: "both",
      fonts: "bookish",
      fontFallback: "system",
      assets: true,
      chapters: 2,
      live: true,
    });

    expect(result.ok).toBe(true);
    if (!result.ok || !result.data) return;

    const { dir, docPath } = result.data;
    const readmePath = join(dir, "README.md");
    const assetsPath = join(dir, "assets");
    const chapter1 = join(dir, "chapters", "chapter-1.flux");

    expect(await exists(docPath)).toBe(true);
    expect(await exists(readmePath)).toBe(true);
    expect(await exists(assetsPath)).toBe(true);
    expect(await exists(chapter1)).toBe(true);

    const fluxText = await readFile(docPath, "utf8");
    const readmeText = await readFile(readmePath, "utf8");

    expect(fluxText).toContain("/// Flux document starter generated by `flux new`.");
    expect(fluxText).toContain("assets {");
    expect(readmeText).toContain("## Preview and export");
    expect(readmeText).toContain("Font fallback:");

    expect(() =>
      parseDocument(fluxText, {
        sourcePath: docPath,
        docRoot: dirname(docPath),
        resolveIncludes: true,
      }),
    ).not.toThrow();
  });

  it("generates templates that parse", async () => {
    const cwd = await mkdtemp(join(tmpdir(), "flux-new-templates-"));
    const templates: TemplateName[] = ["demo", "article", "spec", "zine", "paper", "blank"];

    for (const template of templates) {
      const outDir = join(cwd, template);
      const result = await newCommand({ cwd, template, out: outDir });
      expect(result.ok).toBe(true);
      if (!result.ok || !result.data) {
        continue;
      }

      const { docPath } = result.data;
      const fluxText = await readFile(docPath, "utf8");

      try {
        parseDocument(fluxText, {
          sourcePath: docPath,
          docRoot: dirname(docPath),
          resolveIncludes: true,
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        throw new Error(`Failed to parse ${docPath}: ${message}`);
      }
    }
  });
});
