import { describe, it, expect } from "vitest";
import { mkdtemp, readFile, access } from "node:fs/promises";
import { tmpdir } from "node:os";
import { dirname, join } from "node:path";
import { parseDocument } from "@flux-lang/core";
import { newCommand } from "../src/commands/new.js";

async function exists(path: string): Promise<boolean> {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

describe("cli-core newCommand", () => {
  it("creates files, README, assets, and chapters", async () => {
    const cwd = await mkdtemp(join(tmpdir(), "flux-new-"));
    const result = await newCommand({
      cwd,
      template: "demo",
      out: cwd,
      page: "A4",
      theme: "both",
      fonts: "bookish",
      fontFallback: "system",
      assets: true,
      chapters: 2,
      live: true,
    });

    expect(result.ok).toBe(true);
    if (!result.ok || !result.data) return;

    const { dir, docPath } = result.data;
    const readmePath = join(dir, "README.md");
    const assetsPath = join(dir, "assets");
    const chapter1 = join(dir, "chapters", "chapter-1.flux");

    expect(await exists(docPath)).toBe(true);
    expect(await exists(readmePath)).toBe(true);
    expect(await exists(assetsPath)).toBe(true);
    expect(await exists(chapter1)).toBe(true);

    const fluxText = await readFile(docPath, "utf8");
    const readmeText = await readFile(readmePath, "utf8");

    expect(fluxText).toContain("/// Flux document starter generated by `flux new`.");
    expect(fluxText).toContain("assets {");
    expect(readmeText).toContain("## Preview and export");
    expect(readmeText).toContain("Font fallback:");

    expect(() =>
      parseDocument(fluxText, {
        sourcePath: docPath,
        docRoot: dirname(docPath),
        resolveIncludes: true,
      }),
    ).not.toThrow();
  });
});
